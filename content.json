{"pages":[],"posts":[{"title":"Java内存区域与内存溢出异常","text":"JDK主要是包括Java程序设计语言，Java SE API和Java虚拟机。Java内存管理是深入理解Java虚拟机的第一步。 Java虚拟机在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java虚拟机管理的内存包括如上图的几个运行时数据区域。 程序计数器程序计数器（Program Counter Register）是一块较小的内存区域，它可以看做是当前线程字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都要依赖这个计数器完成。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何时刻，一个处理器都只会执行一条线程中的指令，因此，为了线程切换后还能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程之间计数器互不影响，独立存储， 我们称这类存储区域为线程私有的内存。如果线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是一个本地方法，这个计数器的值则为空。 java虚拟机栈Java虚拟机栈（java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型。每个方法执行的同时都会在虚拟机栈空间创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。其中局部变量表存储了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。关于虚拟机栈可以参考虚拟机字节码执行引擎这一章 本地方法栈本地方法栈与java虚拟机栈类似，只是本地方法栈用于虚拟机调用Native方法。在Hotspot虚拟机中直接将本地方法栈和虚拟机栈合二为一了。 java堆Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。Java堆存在的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配。Java堆也是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆“。从内存回收的角度来看，由于现在收集器基本上都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；更细致的划分有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Threal Local Allocation Buffer, TLAB）。 Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在对中没有内存完成实例分配，并且堆无法再扩展时，将会抛出OutOfMemoryError异常。 方法区方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。一般来说，运行时常量池除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特性是具有动态性，在运行期间可能将新的常量放入池中。 直接内存直接内存（Direct Memory）既不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在NIO中，可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了数据在Java堆和Native堆中来回地复制数据。 对象的创建虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。关于类加载过程可以参考第7章。在类加载完成后，虚拟机将为对象分配内存，对象所需要内存的大小在类加载完成后就确定了。Java分配内存的方式跟垃圾回收紧密相关，如果垃圾回收会整理内存，java使用指针碰撞的方式分配内存，如果垃圾回收不会整理内存，java使用空闲列表的方式分配内存。 在Java中，为对象分配内存不是线程安全的，有两种方法保证线程安全：1，使用同步锁（低效），一种方式是采用CAS配上失败重试的方法保证更新的原子性（Java虚拟机普遍使用的方法，参考CAS&amp;volatile）；2，把内存分配的动作按照线程划分在不同的空间进行，即每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲（TLAB）。那个下线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完病分配新的TLAB时，才需要同步锁。内存分配完毕后，虚拟机将分配到的内存空间都初始化为零值，这也是新建对象时，属性都有默认值的原因。 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到对象的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象的对象头（Object Header）中。此时从虚拟机的角度来看，新对象已经生成了，但是从java语言的角度来看，对象的创建才刚刚开始，初始化方法都还没有执行。 对象的内存布局在Hotspot虚拟机中，对象内存中存储的信息分为3个区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 对象头分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向锁ID、偏向时间戳等，这部分数据成为”Mark Word“, 为32位（32位虚拟机）；第二部分为类型指针，指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。这个指针不是虚拟机所必须的。 Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍，不够的空间通过对齐填充补上。 对象的访问定位两种方法，1：直接访问，在虚拟机栈中存放对象的指针；2,：使用句柄，在java堆中单独划分一块内存作为句柄池，虚拟机栈存放句柄的指针，通过句柄间接访问。","link":"/2020/04/23/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"},{"title":"SecurityContextHolder, SecurityContext 和 Authentication 对象","text":"SecurityContextHolder是应用存储安全相关详情的地方，默认情况下，SecurityContextHolder使用ThreadLocal进行存储，可以说它是线程安全的。 获取当前用户的数据SecurityContextHolder#getContext()用于获取当前用户的SecurityContext对象，如前所属，通过ThreadLocal能正确获取当前线程的SecurityContext. SecurityContext接口源码如下: 123456public interface SecurityContext extends Serializable { // 获取认证对象 Authentication getAuthentication(); // 设置认证对象 void setAuthentication(Authentication authentication);} 可以看出，这个接口主要用于表示认证对象的设置和获取功能，也就是说Spring Security使用Authentication对象表示用户认证信息。通常情况下我们可以通过以下代码获取用户的代理信息，并且这个代理信息在Spring Security中大部分情况下是UserDetails的实例，当然我们也可以自定义其实现。 1234567Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();if (principal instanceof UserDetails) { String username = ((UserDetails)principal).getUsername();} else { String username = principal.toString();} UserDetails源码 123456789101112131415161718192021222324252627282930313233343536public interface UserDetails extends Serializable { /** * 返回用户权限集合，不允许返回null */ Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); /** * 返回用户密码 */ String getPassword(); /** * 返回用于认证的用户名，不允许null */ String getUsername(); /** * 账号是否过期，过期账号不允许认证 */ boolean isAccountNonExpired(); /** * 账号是否锁定，锁定的账号不允许认证 */ boolean isAccountNonLocked(); /** * 用户密码是否过去，过期密码不允许认证 */ boolean isCredentialsNonExpired(); /** * 用户是否解锁，未解锁用户禁止认证 */ boolean isEnabled();} 这个接口定义了大部分情况下需要的功能，可以通过继承这个接口进行扩展 Think of UserDetails as the adapter between your own user database and what Spring Security needs inside the SecurityContextHolder. – spring security doc UserDetailsService接口UserDetailsService接口只定义了一个方法: 1UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; 在spring security中，最常用的加载用户信息的方法就是这个，UserDetailsService的不同实现一般对应了不同的用户信息加载机制，如InMemoryDaoImpl实现从内存中加载用户信息，JdbcDaoImpl则从数据库加载用户信息。可以通过自己实现这个接口自定义用户信息加载途径。 GrantedAuthority在Authentication中，方法getAuthorities()返回一个代表用户权限的集合，这种权限通常用”角色”表示，例如ROLE_ADMINSTRATOR或者ROLE_HR_SUPERVISOR. 小结 SecurityContextHolder提供获取SecurityContext的方法 SecurityContext持有Authentication实例和一些请求相关的安全信息 Authentication表示用户的认证信息 GrantedAuthority表示应用层面的用户的权限信息，通过角色表示 UserDetails提供构建Authentication的必要信息 UserDetailsService通过用户名参数创建UserDetails实例 AuthenticationSpring Security中的认证过程 用户被提示通过用户名和密码登录– 用户名和密码用于构建UsernamePasswordAuthenticationToken(这是Authentication接口的一个实现) 系统验证用户名正确– 将token作为AuthenticationManager的参数用于验证 用户的认证上下文信息被获取– AuthenticationManager返回一个完全填充的Authentication实例 为用户创建安全上下文– 通过SecurityContextHolder.getContext().setAuthentication(...)设置认证信息 用户基于当前上下文继续操作 Web环境中的认证典型web应用的认证过程 浏览主页，点击链接 请求到服务器，服务器发现客户端在访问受保护的资源 但是2中的用户并没有通过，于是服务器返回响应，要求客户端进行认证。这个响应既可以是一个Http状态码或重定向 依赖于认证以及，浏览器会重定向到指定的网页来让用户填写认证信息，或者浏览器通过其它方式来获取认证数据 浏览器向服务器返回一个HTTP响应，它可能是一个包含认证信息表单的请求，或者在HTTP头中设置了认证信息 浏览器决定认证数据是否有效，如果有效，就可以访问受限制的资源了；否则，继续要求认证 原先导致认证发生的请求会重试，如果用户权限足够，则请求成功；否则，返回”403” Spring Security对上述的每一步都会有特定的类进行响应。主要的类是ExceptionTranslationFilter, 核心逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; try { // 这个过滤器没有任何自定义逻辑，只负责捕获异常链中的认证异常，对错误进行转换 chain.doFilter(request, response); logger.debug(\"Chain processed normally\"); } catch (IOException ex) { throw ex; } catch (Exception ex) { // Try to extract a SpringSecurityException from the stacktrace Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex); RuntimeException ase = (AuthenticationException) throwableAnalyzer .getFirstThrowableOfType(AuthenticationException.class, causeChain); if (ase == null) { ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType( AccessDeniedException.class, causeChain); } if (ase != null) { if (response.isCommitted()) { throw new ServletException(\"Unable to handle the Spring Security Exception because the response is already committed.\", ex); } // 处理SpringSecurityException，核心逻辑 handleSpringSecurityException(request, response, chain, ase); } else { // Rethrow ServletExceptions and RuntimeExceptions as-is if (ex instanceof ServletException) { throw (ServletException) ex; } else if (ex instanceof RuntimeException) { throw (RuntimeException) ex; } // Wrap other Exceptions. This shouldn't actually happen // as we've already covered all the possibilities for doFilter throw new RuntimeException(ex); } } } 它提供的服务主要是捕获请求中的认证异常，并通过handleSpringSecurityException方法进行处理 AuthenticationEntryPointAuthenticationEntryPoint是一个认证入口，负责引导用户完成认证。Spring Security提供了几个默认实现： BasicAuthenticationEntryPoint：HTTP基本认证 DelegationAuthenticationEntryPoint: 维护了一个Map，可以根据不同的请求路径调用对应的认证入口 DigestAuthenticationEntryPoint: 摘要认证 Http403ForbiddenEntryPoint: 直接返回403 HttpStatusEntryPoint:返回指定的状态码 LoginUrlAuthenticationEntryPoint: 将请求转发到指定URL进行认证 在请求间保存SecurityContext在Spring Security中，SecurityContextPersistenceFilter过滤器负责保存SecurityContext，默认的实现侧率是将安全上下文作为HttpSession的一个属性进行存储. Spring Security中的访问控制AccessDecisionManager用于实现访问控制 AbstractSecurityInterceptor提供了一致性的工作流用于处理安全对象的请求，典型情况如下： 查询和当前请求相关的”配置属性” 提交安全对象，当前的Authentication以及配置属性给AccessDecisionManager用于权限判定 在调用发生的地方可以选择性地修改Authentication 如果权限正确，则允许调用 如果方法调用成功并且配置了AfterInvocationManager，则调用AfterInvocationManager; 如果调用抛出了异常，AfterInvocationManager就不会被调用 核心ServicesAuthenticationManager, ProviderManager和AuthenticationProviderProviderManager是AuthenticationManager接口的默认实现，但是它自己并不会处理认证相关的事情，而是委托给一个AuthenticationProvider List，其中的每一项都会检查自己是否能执行认证，每个provider要么抛出异常，要么返回一个完全填充的Authentication对象。 认证成功后擦除信息默认情况下，成功认证后ProviderManager会尝试擦除Authentication中的敏感信息，这是为了像密码等信息只在必要的时刻能访问。有时候这种做法会引起问题，比如在无状态的应用中，通过缓存用户数据来提供性能的时候。如果Authentication持有一个指向缓存的引用时，但是这个它的认证信息被擦除了，那样就无法通过认证来获取缓存了。可以考虑复制一个Authentication；另外的一种方法是在ProviderManager中禁止eraseCredentialsAfterAuthentication DaoAuthenticationProvider通过UserDetailsService在数据库中查询用户名，密码和GrantedAuthority. 认证过程也只是通过对UserDetailsService返回的UsernamePasswordAuthenticationToken来对比用户名和密码。 UserDetailsService实现 In-Memory JdbcDaoImpl 认证（Authentication）In-Memory AuthenticationJDBC AuthenticationLDAP AuthenticationAuthenticationProviderAuthenticationProvider Java Configuration","link":"/2020/04/24/spring/spring-security%E6%9E%B6%E6%9E%84%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"title":"Mysql系列之InnoDB存储引擎概述","text":"MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎无关。存储引擎是基于表的，而不是数据库。对于开发人员来说，存储引擎对其是透明的，但了解各种存储引擎的区别对于开发人员来说也是有好处的。对于DBA来说，他们应该深刻地认识到MySQL数据库的核心在于存储引擎。 InnoDB存储引擎将数据放在一个逻辑的表空间中，这个表空间就像黑盒一样由InnoDB存储引擎自身进行管理。InnoDB将每个它管理的表单独存放到一个独立的.ibd文件中。此外，InnoDB存储引擎还支持用裸设备来建立其表空间。 InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同事，使用一种被称为next-key locking的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用性的功能。 对于表中数据的存储，InnoDB采用了聚集（clustered）的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显示地在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并一次作为主键。","link":"/2020/04/24/mysql/mysql-innodb/"},{"title":"Leftmost Column with at Least a One","text":"(This problem is an interactive problem.) A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn’t exist, return -1. You can’t access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface: BinaryMatrix.get(row, col) returns the element of the matrix at index (row, col) (0-indexed). BinaryMatrix.dimensions() returns a list of 2 elements [rows, cols], which means the matrix is rows * cols. Submissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification. For custom testing purposes you’re given the binary matrix mat as input in the following four examples. You will not have access the binary matrix directly. Example 1: 12Input: mat = [[0,0],[1,1]]Output: 0 Example 2: 12Input: mat = [[0,0],[0,1]]Output: 1 Example 3: 12Input: mat = [[0,0],[0,0]]Output: -1 Example 4: 12Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]]Output: 1 Constraints: rows == mat.length cols == mat[i].length 1 &lt;= rows, cols &lt;= 100 mat[i][j] is either 0 or 1. mat[i] is sorted in a non-decreasing way. 思路因为每一行都是单调递增的，可以通过二叉搜索寻找1，考虑到有重复的1，在找到1的情况下，需要找到第一个。根据题意，需要找到第一个出现1的列，假设在第i行的第j列找到了一个1，那么在i+1行只需要在0~j-1列来寻找1了。 solution1234567891011121314151617181920212223242526272829303132333435363738394041/** * // This is the BinaryMatrix's API interface. * // You should not implement it, or speculate about its implementation * interface BinaryMatrix { * public int get(int row, int col) {} * public List&lt;Integer&gt; dimensions {} * }; */class Solution { public int leftMostColumnWithOne(BinaryMatrix binaryMatrix) { List&lt;Integer&gt; dimensions = binaryMatrix.dimensions(); int rows = dimensions.get(0); int cols = dimensions.get(1); int res = Integer.MAX_VALUE; for (int row = 0; row &lt; rows; row++) { int index = binarySearchOne(binaryMatrix, row, Math.min(res, cols-1)); res = Math.min(res, index); } return res == Integer.MAX_VALUE ? -1 : res; } private int binarySearchOne(BinaryMatrix binaryMatrix, int row, int cols) { int start = 0; int end = cols; while (start &lt;= end) { int mid = start + (end-start) / 2; int val = binaryMatrix.get(row, mid); if (val == 1) { while (mid &gt; 0 &amp;&amp; binaryMatrix.get(row, mid-1) == 1) { mid--; } return mid; } else { start = mid+1; } } return Integer.MAX_VALUE; }}","link":"/2020/04/26/leetcode/Leftmost-Column-with-at-Least-a-One/"},{"title":"LRU Cache","text":"Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 思路根据LRU的性质可知，应该是需要一个链表来存储相关的数据的，这是因为删除将数据节点挪到前端的成本低（相较于数据），同时题目要求查找的时间也要是O(1)，因此还需要一个map对数据进行映射。为了在O(1)时间挪动数据节点，链表应该是双向链表。当从LRU列表中删除节点时，同时需要删除map中的key，这时需要有一个节点到map的key的映射，可以为此再新建一个map，但是在数据节点中直接存储这个key会更好一些。删除节点需要考虑头和尾的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108class LRUCache { private Node head; private Node tail; private Map&lt;Integer, Node&gt; map; private int capacity; private int size; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap&lt;&gt;(); } public int get(int key) { Node node = map.get(key); if (node == null) { return -1; } if (node == head) { return node.val; } Node last = node.last; Node next = node.next; last.next = node.next; if (next != null) { next.last = last; } else { tail = last; } node.next = head; node.last = null; head.last = node; head = node; return head.val; } public void put(int key, int value) { Node targetNode = map.get(key); if (targetNode != null) { targetNode.val = value; if (targetNode != head) { Node next = targetNode.next; Node last = targetNode.last; last.next = next; if (next == null) { tail = last; } else { next.last = last; } targetNode.next = head; head.last = targetNode; head = targetNode; } return; } if (size == 0) { Node node = new Node(key, value); head = tail = node; size++; map.put(key, node); } else if (size &lt; capacity) { Node node = new Node(key, value); node.next = head; head.last = node; head = node; size++; map.put(key, node); } else { Node node = new Node(key, value); node.next = head; head.last = node; head = node; map.put(key, node); Node ex = tail; Node last = tail.last; ex.last = null; last.next = null; tail = last; map.remove(ex.key); } }}class Node { int key; int val; Node next; Node last; public Node(int key, int val) { this.key = key; this.val = val; }}/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */","link":"/2020/04/27/leetcode/LRU-Cache/"},{"title":"Maximal Square","text":"Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: 12345678Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Output: 4 思路这是一道dp题，定义dp[row][col]为第row行第col列的正方形的边长，显然，如果matrix[row][col] == 0，此时dp[row][col] = 0. 否则，根据dp[row-1][col-1]的值edge，从当前点往外延申，边长一直算到edge，如果这两边都为1，dp[row][col] = edge + 1. res = max(res, dp[row][col] ^2). 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int maximalSquare(char[][] matrix) { int res = 0; int height = matrix.length; if (height == 0) { return 0; } int width = matrix[0].length; if (width == 0) { return 0; } int[][] dp = new int[height][width]; for (int row = 0; row &lt; height; row++) { for (int col = 0; col &lt; width; col++) { if (matrix[row][col] == '0') { System.out.print(dp[row][col] + \" \"); continue; } if (row == 0 || col == 0 || dp[row-1][col-1] == 0) { dp[row][col] = 1; res = Math.max(res, 1); } else { int edge = 0; while (edge &lt; dp[row-1][col-1]) { if (matrix[row-edge-1][col] != '1' || matrix[row][col-edge-1] != '1') { break; } edge++; } dp[row][col] = 1 + edge; res = Math.max(res, dp[row][col] * dp[row][col]); } System.out.print(dp[row][col] + \" \"); } System.out.println(); } return res; }}","link":"/2020/04/27/leetcode/Maximal-Square/"},{"title":"Predict the Winner","text":"Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. Example 1: 123Input: [1, 5, 2]Output: FalseExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False. Example 2: 123Input: [1, 5, 233, 7]Output: TrueExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win. 思路这是一道博弈题，根据所学知识，博弈题可以根据相对得分来确定结果。玩家获胜的条件是在当前数据下，玩家获取的相对得分大于或等于0是赢得游戏的条件，按照游戏规则，当前玩家能获得的相对分数的公式应该是Math.max(nums[start]-score(nums, start+1, end), nums[end]-score(nums, start, end-1)).也就是玩家从头或者从尾部取值，减去另外一个玩家所能获取的最大分数，再在两个差值间寻找最大值即为本轮的相对分数。 12345678910111213141516class Solution { public boolean PredictTheWinner(int[] nums) { return score(nums, 0, nums.length-1) &gt;= 0; } private int score(int[] nums, int start, int end) { if (start &gt; end) { return 0; } if (start == end) { return nums[start]; } return Math.max(nums[start] - score(nums, start+1, end), nums[end] - score(nums, start, end-1)); }} 可以使用记忆化递归优化递归调用 123456789101112131415161718class Solution { private Integer[][] dp; public boolean PredictTheWinner(int[] nums) { dp = new Integer[nums.length][nums.length]; return score(nums, 0, nums.length-1) &gt;= 0; } private int score(int[] nums, int start, int end) { if (start &gt; end) { return 0; } if (dp[start][end] != null) { return dp[start][end]; } dp[start][end] = Math.max(nums[start] - score(nums, start+1, end), nums[end] - score(nums, start, end-1)); return dp[start][end]; }}","link":"/2020/04/28/leetcode/Predict-the-Winner/"},{"title":"First Unique Number","text":"You have a queue of integers, you need to retrieve the first unique integer in the queue. Implement the FirstUnique class: FirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Example 1: 123456789101112131415Input: [&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;][[[2,3,5]],[],[5],[],[2],[],[3],[]]Output: [null,2,null,2,null,3,null,-1]Explanation: FirstUnique firstUnique = new FirstUnique([2,3,5]);firstUnique.showFirstUnique(); // return 2firstUnique.add(5); // the queue is now [2,3,5,5]firstUnique.showFirstUnique(); // return 2firstUnique.add(2); // the queue is now [2,3,5,5,2]firstUnique.showFirstUnique(); // return 3firstUnique.add(3); // the queue is now [2,3,5,5,2,3]firstUnique.showFirstUnique(); // return -1 Example 2: 123456789101112131415Input: [&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;][[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]]Output: [null,-1,null,null,null,null,null,17]Explanation: FirstUnique firstUnique = new FirstUnique([7,7,7,7,7,7]);firstUnique.showFirstUnique(); // return -1firstUnique.add(7); // the queue is now [7,7,7,7,7,7,7]firstUnique.add(3); // the queue is now [7,7,7,7,7,7,7,3]firstUnique.add(3); // the queue is now [7,7,7,7,7,7,7,3,3]firstUnique.add(7); // the queue is now [7,7,7,7,7,7,7,3,3,7]firstUnique.add(17); // the queue is now [7,7,7,7,7,7,7,3,3,7,17]firstUnique.showFirstUnique(); // return 17 Example 3: 1234567891011Input: [&quot;FirstUnique&quot;,&quot;showFirstUnique&quot;,&quot;add&quot;,&quot;showFirstUnique&quot;][[[809]],[],[809],[]]Output: [null,809,null,-1]Explanation: FirstUnique firstUnique = new FirstUnique([809]);firstUnique.showFirstUnique(); // return 809firstUnique.add(809); // the queue is now [809,809]firstUnique.showFirstUnique(); // return -1 思路首先考虑使用数组存储唯一的数字，但是随着相同数据的加入，数据可能会移除数组。使用链表和HashMap的数据结构进行存储。链表只存储唯一的数字，map存储数字到节点的映射。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class FirstUnique { Map&lt;Integer, Node&gt; map; Node head; Node tail; public FirstUnique(int[] nums) { map = new HashMap&lt;&gt;(); for (int num : nums) { add(num); } } public int showFirstUnique() { if (head == null) { return -1; } return head.num; } public void add(int value) { if (map.containsKey(value)) { removeNode(value); return; } Node node = new Node(value); addTail(node); map.put(value, node); } private void addTail(Node node) { if (head == null) { head = tail = node; } else { tail.next = node; node.last = tail; tail = node; } } private void removeNode(int val) { Node node = map.get(val); if (node == null) { return; } Node last = node.last; Node next = node.next; if (head == tail) { head = tail = null; } else if (last == null) { head = next; next.last = null; } else if (next == null) { last.next = null; tail = last; } else { last.next = next; next.last = last; node.next = null; node.last = null; } map.put(val, null); }}class Node { int num; Node last; Node next; Node(int num) { this.num = num; }}/** * Your FirstUnique object will be instantiated and called as such: * FirstUnique obj = new FirstUnique(nums); * int param_1 = obj.showFirstUnique(); * obj.add(value); */","link":"/2020/04/28/leetcode/First-Unique-Number/"},{"title":"Binary Tree Maximum Path Sum","text":"Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: 1234567Input: [1,2,3] 1 / \\ 2 3Output: 6 Example 2: 123456789Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7Output: 42 思路考虑节点n（必须包含节点n）能得到的最大和，它所能得到的最大值应该是它左节点能得到的最大值 + 右节点能得到的最大值和它自己的值，即maxScore(node) = maxScore(node.left) + maxScore(node.right) + node.val. 根据题目的意思，可以不从根节点开始算，那么就必须在递归求解子节点的最大分数时来更新最终的结果。这样，当求解根节点的maxScore时，我们得到的不一定是全局最大值，但是在递归求解的时候已经更新了全局最大值了。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { int res; public int maxPathSum(TreeNode root) { res = Integer.MIN_VALUE; helper(root); return res; } private int helper(TreeNode root) { if (root == null) { return 0; } int left = Math.max(0, helper(root.left)); int right = Math.max(0, helper(root.right)); res = Math.max(res, left + right + root.val); return Math.max(left, right) + root.val; }}","link":"/2020/04/29/leetcode/Binary-Tree-Maximum-Path-Sum/"},{"title":"Range Sum of BST","text":"Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values. Example 1: 12Input: root = [10,5,15,3,7,null,18], L = 7, R = 15Output: 32 Example 2: 12Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10Output: 23 思路这是一道遍历二叉树的题目，可以通过前序，中序，后序实现。判断当前节点，如果节点的值在给定范围内，则将其加入到全局结果中。 前序遍历1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { private int res; public int rangeSumBST(TreeNode root, int L, int R) { if (root == null) { return 0; } if (root.val &gt;= L &amp;&amp; root.val &lt;= R) { res += root.val; } rangeSumBST(root.left, L, R); rangeSumBST(root.right, L, R); return res; }} 中序遍历1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { private int res; public int rangeSumBST(TreeNode root, int L, int R) { if (root == null) { return 0; } rangeSumBST(root.left, L, R); if (root.val &gt;= L &amp;&amp; root.val &lt;= R) { res += root.val; } rangeSumBST(root.right, L, R); return res; }} 后续遍历1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { private int res; public int rangeSumBST(TreeNode root, int L, int R) { if (root == null) { return 0; } rangeSumBST(root.left, L, R); rangeSumBST(root.right, L, R); if (root.val &gt;= L &amp;&amp; root.val &lt;= R) { res += root.val; } return res; }}","link":"/2020/05/02/leetcode/Range-Sum-of-BST/"},{"title":"Merge Two Binary Trees","text":"Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: 1234567891011121314Input: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output: Merged tree: 3 / \\ 4 5 / \\ \\ 5 4 7 思路这道题的思路应该是递归实现的，先合并根节点，再合并左子树，最后合并右子树。可能出现的情况是当前节点有一个为null，那当前节点的取值为不为null的值，而子树则为不为null节点的子树。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { TreeNode newNode; if (t1 == null &amp;&amp; t2 == null) { return null; } else if (t1 == null) { newNode = new TreeNode(t2.val); } else if (t2 == null) { newNode = new TreeNode(t1.val); } else { newNode = new TreeNode(t1.val + t2.val); } newNode.left = mergeTrees(t1 == null ? null : t1.left, t2 == null ? null : t2.left); newNode.right = mergeTrees(t1 == null ? null : t1.right, t2 == null ? null : t2.right); return newNode; }} 上述解法对于节点为null的情况没有进行优化，实际上，当碰到一个节点为null时，后续的递归调用没有必要再进行了，只需要将另一个节点的子树作为子树复制给当前节点即可。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { TreeNode newNode; if (t1 == null &amp;&amp; t2 == null) { return null; } else if (t1 == null) { newNode = new TreeNode(t2.val); } else if (t2 == null) { newNode = new TreeNode(t1.val); } else { newNode = new TreeNode(t1.val + t2.val); } if (t1 == null) { // 碰到null节点可以停止递归调用了 newNode.left = t2 == null ? null : t2.left; newNode.right = t2 == null ? null : t2.right; } else { // 也是跳过null节点的递归调用 newNode.left = t2 == null ? t1.left : mergeTrees(t1.left, t2.left); newNode.right = t2 == null ? t1.right : mergeTrees(t1.right, t2.right); } // newNode.left = mergeTrees(t1 == null ? null : t1.left, t2 == null ? null : t2.left); // newNode.right = mergeTrees(t1 == null ? null : t1.right, t2 == null ? null : t2.right); return newNode; }}","link":"/2020/05/02/leetcode/Merge-Two-Binary-Trees/"},{"title":"N-ary Tree Preorder Traversal","text":"Given an n-ary tree, return the preorder traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Follow up: Recursive solution is trivial, could you do it iteratively? Example 1: 12Input: root = [1,null,3,2,4,null,5,6]Output: [1,3,5,6,2,4] Example 2: 12Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10] 思路不管多少叉树，前序遍历的顺序是先根节点，再子节点；后续遍历的顺序是先子节点，再根节点。对于多叉树，中序遍历没什么意义，因为根节点不知道放在子节点的什么位置，对于二叉树，中序遍历是左子树，根节点，右子树。 递归调用12345678910111213141516171819202122232425262728293031323334353637383940/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { public List&lt;Integer&gt; preorder(Node root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); preorder(root, res); return res; } private void preorder(Node root, List&lt;Integer&gt; list) { if (root == null) { return; } list.add(root.val); List&lt;Node&gt; children = root.children; for (Node child : children) { if (child != null) { preorder(child, list); } } }} follow up使用迭代实现与二叉树的迭代遍历一样，都可以使用栈这种数据结构来完成，需要记住的是子节点的压栈顺序应该是从右往左的，这样才能保证出栈的顺序是从左往右的，这也是栈这种数据结构的性质决定的。在java语言种，Deque这种数据结构也叫双端队列，虽然也有Stack这种数据结构实现了栈，但是Stack是一个同步类，因为Stack继承Vector，这本身就是一个很蠢的设计，然而Deque又违背了封装的原则，相关的吐槽可以参考这里http://baddotrobot.com/blog/2013/01/10/stack-vs-deque/。我倾向于使用Deque来实现Stack。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { public List&lt;Integer&gt; preorder(Node root) { if (root == null) { return new ArrayList&lt;&gt;(); } Deque&lt;Node&gt; deque = new ArrayDeque&lt;&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); deque.offerLast(root); while (!deque.isEmpty()) { Node node = deque.pollLast(); res.add(node.val); List&lt;Node&gt; children = node.children; if (children != null &amp;&amp; !children.isEmpty()) { int size = children.size(); for (int i = size-1; i &gt;= 0; i--) { Node curr = children.get(i); if (curr != null) { deque.offerLast(curr); } } } } return res; } } 但目前的问题是为什么使用栈的执行时间比递归调用还长？！！！","link":"/2020/05/02/leetcode/N-ary-Tree-Preorder-Traversal/"},{"title":"Push Dominoes","text":"There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string “S” representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed. Return a string representing the final state. Example 1: 12Input: &quot;.L.R...LR..L..&quot;Output: &quot;LL.RR.LLRRLL..&quot; Example 2: 123Input: &quot;RR.L&quot;Output: &quot;RR.L&quot;Explanation: The first domino expends no additional force on the second domino. Note: 0 &lt;= N &lt;= 10^5 String dominoes contains only 'L‘, 'R' and '.' 思路如果从左右两边来看的话，在左边，往左边push的牌会把所有它左边的牌往左推倒，直到碰到往右推的牌。同理，在右边，往右边push的牌会把所有它右边的牌往右推倒，直到碰到往左推的牌。还有一种情况是，以左边为例，往左倒的牌在碰到它能碰到的第一个往右倒的牌之前已经有往左倒的牌了，这部分的牌应该全部往左倒。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution { public String pushDominoes(String dominoes) { int N = dominoes.length(); char[] res = new char[N]; int lastRightPush = -1; int lastLeftPush = -1; for (int i = 0; i &lt; N; i++) { char c = dominoes.charAt(i); if (c == '.') { res[i] = c; } else if (c == 'L') { res[i] = c; if (lastRightPush &gt; lastLeftPush) { // R...L for (int j = lastRightPush+1; j &lt; i; j++) { int leftLen = j - lastRightPush; int rightLen = i - j; if (leftLen &lt; rightLen) { res[j] = 'R'; } else if (leftLen == rightLen) { res[j] = '.'; } else { res[j] = 'L'; } } } else if (lastRightPush &lt; lastLeftPush) { // L...L for (int j = lastLeftPush+1; j &lt;i; j++) { res[j] = 'L'; } } else { // ...L for (int j = 0; j &lt; i; j++) { res[j] = c; } } lastLeftPush = i; } else { res[i] = 'R'; if (lastLeftPush &lt; lastRightPush) { // R...R for (int j = lastRightPush+1; j &lt; i; j++) { res[j] = 'R'; } } lastRightPush = i; } } if (lastRightPush &gt; lastLeftPush) { // R... for (int i = lastRightPush; i &lt; N; i++) { res[i] = 'R'; } } return String.valueOf(res); }} 参考方法一，只记录符号为’L’或者’R’的符号以及位置，对每个区间有以下三种情形: “L…..L” 或者”R……R”, 此时只需要更新中间的状态为边上的即可, “R…..L”, 计算中间牌的状态，并更新 “L……R” 中间牌的状态不变 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public String pushDominoes(String dominoes) { int N = dominoes.length(); int[] indexes = new int[N+2]; char[] symbols = new char[N+2]; indexes[0] = -1; symbols[0] = 'L'; int l = 1; for (int i = 0; i &lt; N; i++) { char c = dominoes.charAt(i); if (c != '.') { indexes[l] = i; symbols[l] = c; l++; } } indexes[l] = N; symbols[l] = 'R'; l++; char[] res = dominoes.toCharArray(); for (int index = 0; index &lt; l-1; index++) { int start = indexes[index]; int end = indexes[index+1]; char x = symbols[index]; char y = symbols[index+1]; if (x == y) { // L.....L or R.....R for (int i = start+1; i &lt; end; i++) { res[i] = x; } } else if (x &gt; y) { // R....L for (int i = start+1; i &lt; end; i++) { int leftLen = i - start; int rightLen = end - i; if (leftLen == rightLen) { res[i] = '.'; } else if (leftLen &lt; rightLen) { res[i] = 'R'; } else { res[i] = 'L'; } } } } return String.valueOf(res); }} 方法二，从左往右计算往右推的力，从右计算往左推的力，最后根据力的状态来决定当前位置牌的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public String pushDominoes(String dominoes) { int N = dominoes.length(); int[] forces = new int[N]; int force = 0; for (int i = 0; i &lt; N; i++) { char c = dominoes.charAt(i); if (c == 'R') { force = N; } else if (c == 'L') { force = 0; } else { force = Math.max(force - 1, 0); } forces[i] += force; } // cal force diff for (int i = N-1; i &gt;= 0; i--) { char c = dominoes.charAt(i); if (c == 'L') { force = N; } else if (c == 'R') { force = 0; } else { force = Math.max(force - 1, 0); } forces[i] -= force; } char[] res = new char[N]; for (int i = 0; i &lt; N; i++) { if (forces[i] == 0) { res[i] = '.'; } else if (forces[i] &gt; 0) { res[i] = 'R'; } else { res[i] = 'L'; } } return String.valueOf(res); }}","link":"/2020/05/03/leetcode/Push-Dominoes/"}],"tags":[{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"spring security","slug":"spring-security","link":"/tags/spring-security/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"innodb","slug":"innodb","link":"/tags/innodb/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"dp","slug":"dp","link":"/tags/dp/"}],"categories":[{"name":"java","slug":"java","link":"/categories/java/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"algorithms","slug":"algorithms","link":"/categories/algorithms/"}]}